day1 2022.10.24  	 Powershell	d:目录变更为d盘  mkdir创建目录  python ex.py运行代码
									 python			ex1:	print()打印
									 						ex2:	#注释
									 						ex3:	数字计算
									 						ex4:	变量和命名
									 						ex5:	print(f{})打印字符串  round()四舍五入

day2 2022.10.25		 python			ex6:	字符串和文本 初见format
									 						ex7:	习题 end=' '可不打印新一行<Cheese Burger>
									 						ex8:	函数的使用 若没有，字符串会合并
									 						ex9:	"""   """字符串跨行   \n换行  \转义(" \" ")
									 						ex10:	转义序列 基础篇P32

day3 2022.10.26		 python			ex11:input()输入内容  int(input())获取数字
									 						ex12:input("提示内容") pydoc文档生成工具
									 						ex13:import语句调用模块(库) argv(argument variable)参数变量 unpack解包
									 						ex14:argv与input结合使用  用户提示符设为变量可方便更改 prompt = ">"  input(prompt)
									 						ex15:open( , encoding="utf-8")显示汉字

day4 2022.10.27		 Powershell ni name创建文件
									 python			ex16:文件及时使用close关闭文件防止循环导致溢出
									 						ex17:复制文件 open与read可以合并成indata = open().read()          print(">>>> file=", repr(file))  repr()返回一个对象的字符串格式(左右加引号)
									 						ex18:def function(variable)创建函数       def 函数名(变量,变量):
									 						ex19:函数里的变量与脚本里的变量没有联系，可以使用字符串、数字、变量、数字计算、变量+数字计算等方式将变量输送给函数  函数栈是临时的 不会储存数据
									 						ex20:见操作文件
									 						ex21:return x返回值到变量中 可以是数，字符串等
									 						ex22:总结
									 						ex23:字符串、字节串和字符编码 ASCII utf-8

day5 2022.10.28		 python			ex24:"".format()另一种格式字符串的方式  variable = function(x) [function return a, b, c] 将列表应用于格式字符串  format(*variable)依次输入列表变量
									 						ex25:sorted()排序(用于非列表, 列表可以直接使用.sort)
									 						ex26:纠错练习 a += 1  <===>  a = a + 1
									 						ex27:True和False的逻辑关系
									 						ex28:布尔表达式练习
									 						ex29:if语句 #为什么这一节的习题会出现在ex26中？
									 						ex30:else 和 if语句
									 						ex31:一个小游戏if-elif-else练习的小游戏  判断取值可以用1 < x < 10或是x in range(1,10)(1~9)		range(起始数，结束数，步长)
									 						ex32:列表list = [1, 2, 3, "a", "b", "c"]   for i in x for循环
									 						     in/not in存在/不存在则返回True

day6 2022.10.29    python			ex33:while循环
									 						ex34:列表的元素位置  0为正数第一个 -1为倒数第一个
									 						ex35:exit(0)无错误退出  exit(1)有错误退出   exit∈sys
									 						ex36:设计和调试 if语句的规则 循环的规则 家庭作业
									 						ex37:各种符号与关键字
									 						ex38:见str.
									 						ex39:list(stuff.items())可将字典中的内容生成列表
									 						ex40:import xxx模块、class类和object对象  class类(https://zhuanlan.zhihu.com/p/30024792)(https://blog.csdn.net/weixin_45410337/article/details/97423095)

day7 2022.10.30 	 python			ex41:oop理解小测试 运行ex41.py即可(代码为用单词替换PHRASES字典中的@@@、***、%%%、等字符，无需看懂) 运行ex41.py时若加上第二个参数english,则问题和答案互换
									 						ex42:父类-子类 super(类名,self).父类方法名 调用父类的方法进行重写扩展  在class定义的函数即为方法
									 						ex43:randint(0.200)随机数∈random  dedent("""xxx""")删除每行字符串前面的空格∈textwrap   面向对象小游戏练习

day8-15 2022.10.31 python 		ex44:隐式继承 显式覆盖 super重写扩展   在__init__中使用self.变量 = 类名()可实现继承功能(set.other = Other())  后续方法可通过self.other.方法名()调用Other()中的函数
		   -2022.11.06 						ex45:自制一款游戏
									 						day1:基础框架仿照ex43写好  import re >> ''.join(re.findall('[\u4e00-\u9fa5]',变量名))可提取中文
                              day2:if " " in 字符串 可以用来判断用户是否输入了指定的指令  创建了打印行的模块import print_line  import 模块名 an 字符(p)可在调用函数时进行缩写(p.printline())
																	 思路:将打印习题内容改为指定打印行数，减少主函数的内容 ===>创建Ex.py 定义数个Ex函数存放纯文字内容，在主函数里直接引用
															day3:将介绍文档用readlines转换为列表进行切片打印 可以循环使用 不再被readline所限制 ===>课题内容也可写进Ex.txt文本直接切片打印
																	 ''.join([i for i in a if not i.isdigit()])   ''.join(变量)将变量中的字符用None相连  float()浮点数  eval()去除字符串两边的括号
																	 思路:定义一个延时函数，所有延时使用该函数，程序开始时让用户输入延时时间 ===>直接开始定义个time = input(),使用sleep(time)
																	 pyinstaller [主文件] -p [其他文件1] -p [其他文件2] -p [其他文件3] --hidden-import [自建模块1] --hidden-import [自建模块2] --hidden-import [自建模块3]
																	 双层循环可以在break第一层循环时定义个变量，第二层循环用if停止
															day4:思路:设置一个选关程序  isalnum()判断字符和数字  alpha()判断字符  ex4的各种判断太麻烦了！！
															day5:新发现四个bug,用了个超长的if语句修好了^_^  except捕获异常  len(input()) == 0可以判断无输入	len(list/str/dict)求长度
															day6:思路:将字体每行显示改为在每行的基础上每字显示√  flush=True可以让print在不换行的情况下马上显示内容
																	 变量名.read().splitlines()可以去掉readlines中的换行符
															day7:将剩余的字全部放入txt 封装成exe进行试玩

——————————————————————————————复习学校考试

day16 2022.11.18	 python			ex46:创建虚拟环境 .\activate进入虚拟环境 制作项目骨架
															ex47:assert断言函数(https://www.cnblogs.com/llsix/p/8474322.html)  .update({a: b})更新字典
															ex48:用户输入进阶  元组(tuple)不能修改的列表  isdigit只对字符串起作用
																	 大小写转换 例如.lower() .upper()(https://blog.csdn.net/cw7600/article/details/126612352)
															ex49:创建句子 感觉和ex48用处不大，暂时跳过


day17 2022.11.19	 Powershell set设置环境变量 Linus中用export   mkdir -p name1,name2可一次性创建多个文件夹
									 python			ex50:flask框架创建web  app.debug=True可以在运行时打开debug模式  !!!!!!!注意模块与python的版本是否有冲突!!!!!!!
									 HTML            {% 可执行代码 %}  {{ 文本变量 }}

day18 2022.11.20   python		  ex51:request.args从url获取数据 request.form从表单获取数据  ex52暂时搁置
									 HTML            action="/hello"请求发送给/hello URL  <input type=" " name=" ">获取输入
									 								 {% entends "layout.html" %} 和 {% block content %} {% endblock %}可以将页面顶部和底部反复用到的样板代码剥掉并用layout.html处理

——————————————————————————————装Linus虚拟机

day19 2022.11.21   python     研究pygame,优化ex45中我自己的游戏(http://m.biancheng.net/pygame/what-is-pygame.html)
															输入框完成 实现选中输入框后输入框变色 可以输入内容
															思路:设计一个类似插入点的竖线，功能先搁置 也许可以通过每输入/删除一个字符就刷新插入点的位置来实现

day20 2022.11.22   python     输入start后游戏开始 输入框上方应显示所输入的指令 下方应显示游戏文本(未完成)

day21 2022.11.23   python     已可以把ex45的代码整合进pygame程序里，但还不知道怎么调用库，只能把自制库中的代码也一并整合进来
															尝试在自建print库中设计打印程序成功，但逐字打印并显示功能还不知如何实现，在函数运行完之前屏幕似乎不会刷新
															我是弱智 刷新指令忘记打()了  b = [line.strip("\n") for line in b]可以将readlines后的列表中删掉\n(列表生成式https://blog.csdn.net/qdPython/article/details/126725534)
															逐行逐字打印已经实现，接下来需要做的是在打完一行后将上一行文字上移，而在文字原本的位置上继续打印下一行
															思路:在事件空闲期当玩家使用鼠标滚轮，显示本题全部文字

day22 2022.11.24   python     换行后本行文字上移以完成  用户可输入字句间隔时间完成  目前只剩下游戏程序的运行  若是通过库引用程序需要将ex45_main用pygame大改,所以决定直接整合进主函数
															目前问题:二重循环时只能将事件获取的代码再次输入一次，不知道是否有更好的方法

day23 2022.11.25   python     ex1基本上做完了 但目前有个问题是游戏文本更新刷新屏幕时下方显示的用户输入的代码也会被刷掉

day24 2022.11.28   python     ex1全部完成

day25 2022.11.29   python     尝试了一下在调用打印自制库时不未响应，若用wait时需要有事件才能打印，若用get会报错 先改回来了
															修了一下bug 制作ex2 修改了一下ex1的细节

day26 2022.11.30   python     完成了ex3 修复了ex2的已知bug

day27 2022.12.03   python     完成了ex4 修改了剩下的文档内容，使其可以正确的在软件中换行打印
															对print模块进行了更改，在打印文字的时候不会未响应了！
															明天如果没什么事情做完ex5那这个软件的测试版就算是全部完成了

day28 2022.12.04	 python     完成了ex5 设置了一个简单的开发人员的跳关系统
															目前算是全部完成了，后续看看能不能把界面做的更加精美，再加上些音效什么的
															../可以获取上一级目录的文件

day29 2022.12.05	 python     pygame音效(https://wenku.baidu.com/view/9c930b0a29f90242a8956bec0975f46527d3a794.html?_wkts_=1670248443710&bdQuery=pygame%E6%8F%92%E5%85%A5%E9%9F%B3%E6%95%88)
															添加了点击输入框的音效与键盘打字的音效  目前发现的bug:在软件进行打印提示语的时候会出现打字音效
															还需要每一关尝试一下 有些地方连接性有些问题

day30 2022.12.10   python			ex1pro~3pro:关于流程-创新-质量
															ex4:处理命令行参数	→尝试使用新的模块时(argparse)先阅读文档/教程(https://blog.csdn.net/weixin_42725119/article/details/127657832)

day31 2022.12.11	 python			ex5:cat命令 →做新项目时的启动能力与阻力
															ex6~ex12:全都是用argparse去实现终端的功能，跳过
															ex13:链表 尝试设计python中的list和其的功能指令
															ex14:双链表
															又修复了一下自制程序的一些bug  研究了一下GitHub

day32	2023.03.29	 python			names = ["Alice", "Bob", "Carl"]									可以替代for i in range(len(names)):
															for index,value in enumerate(names):												print(f'{i}: {names[i]}')
																print(f'{index}: {value}')

															enmuerate(li, 1) 可以将上述代码的0 1 2更改为1 2 3
															list(range(x))可以直接创建x位数的列表
															index为线性查找
															li[j], li[j+1] = li[j+1], li[j] 可以同时交换两个数

day33 2023.03.30   python     四种算法:冒泡、选择、插入、快速

day34 2023.03.31   python			id(变量名)可以看到物理地址(内存地址)
															python解释器也自带垃圾回收器,可以回收无用的内存地址
															name2 = name时是指向name的内存地址，不会生成新地址
															ctrl D = 复制并在下一行输入本行代码
															ctrl ? = 注释掉选中的所有行

day35 2023.04.01	 python			exit("字符串")可以退出整个程序的同时打印一次字符串
															python中while和for都可以接else
															"".join()可以用于将列表中的元素进行拼接
															random模块:
																				import random
																				random.choice('字符串/列表'): 返回一个随机字符/元素
																				random.sample(列表,数量): 随机从列表中抽取设置的数量个元素
																				random.randint(1,100): 返回一个1-100的随机整数, 包括100
																				random.uniform(1,10)： 返回一个范围内的随机小数
																				random.randrange(1,10): 返回一个1-10的随机数, 不包括10
																				random.randrange(0,100,2): 返回一个0-100的偶数
																				random.random(): 返回一个随机浮点数
																				random.shuffle(变量名): 打乱列表中的顺序, 可以配合list(range(100))使用生成100个乱序数
															''.join(random.sample(string.ascii_lowercase + string.digits, 6)): 随机生成6位数字符串
															string模块:
																				import string
																				string.ascii_letters:输出所有小写和大写字母
																				string.ascii_uppercase:输出所有大写字母
																				string.ascii_lowercase:输出所有小写字母
																				string.punctuation:输出特殊字符
																				string.digits:输出0-9的数字
														  print中的f"{}"可以直接用于list
															如：c_num = f"京{}-{}"
																 car_nums.append(c_num)
															判断列表中是否有某个元素常使用in

															heapq模块(堆排序):
																							 heapq.heapify(list):建小根堆
																							 heapq.heappop(list):弹出最小元素, 想排序的话可以循环加入新list
															topk问题使用小根堆可达到O(nlogk)

															str(字符串):
																				 str.center(总字节数,'填充的字符')	:使用字符填充左右空位
																				 str.count("字符", 起始, 结束)	:搜索字符出现多少次, 位置默认全部
																				 str.endswith("字符串")	:判断结尾
																				 str.startswith("字符串")	:判断开头
																				 str.find("字符")	:找到时返回下标，否则返回-1
																				 str.isdigit()	:判断是否是整数
																				 str2 = "字符".join(list/str)	:使用字符拼接
																				 str2 = str.replace(想要替换的内容, 替换的内容, 替换个数)	:可以替换字符
																				 str.strip("字符")	:删除左右的字符，默认为空格 .rstrip与.lstrip同理，单独分左右
																				 str.split("字符", 分几次)	:把字符串按字符分隔成列表, 默认为空格和全分

															list(列表):
																				 li[i] = ""	:修改列表
																				 li[起始:结束:步数]	:切片
																				 del li[i]	:删除下标为i的元素
																				 li.append("字符串")	:在尾部追加
																				 li.insert(下标, "字符串")	:在下标处添加, 后续元素依次后移一位
																				 li.extend(li2)	:在列表li后添加列表li2
																				 li.pop(下标)	:弹出(删除并返回)，默认最后一位
																				 li.remove("元素名")	:从左删除第一个找到的元素
																				 li.clear()	:清空
																				 li.sort()	:排序
																				 li.index("元素名")	:查找元素名下标
																				 li.count("元素名")	:查找元素个数
																				 li.reverse()	:反转列表
																				 item in li	:判断item是否在列表中
																				 enumerate(li)	:枚举，带下标值

day36 2023.04.02	 python			dict(字典):
																				 dict = {"key":"value", "key2":"value2"}	:value可以为列表/字典/字符串等(一个key对应多个value)
																				 dict["key"] = "value"	:添加/修改字典
																				 dict.setdefaule("key", "value"): 添加新内容, 若key存在则无效
																				 dict.update({"key1":value1, "key2":value2}): 没有的key添加, 有的key更新
																				 dict.pop("key"): 弹出指定key, 将value返回
																				 dict.popitem(): 弹出最后元素, 返回(key, value)
																				 del dict["key"]	:删除
																				 dict.pop["key"]	:弹出
																				 dict["key"]	:取value
																				 "key" in dict	:判断是否存在
																				 dict.keys()	:返回字典中所有的key的列表
																				 dict.values()	:返回字典中所有value的列表
																				 dict.items()	:返回一个包含所有元组的列表
																				 dict.get("key", 返回值)	:返回key对应的value值，若不存在key则返回返回值

															当for循环的字典/列表等东西中含有两个元素，可以使用for i,j in dict.item
															bit:表示单位	bytes:存储单位
															sort方法是基于归并与插入进行优化后的排序
															一般情况下排序运行时间:快速排序>归并排序>堆排序
															缺点:快速排序:极端情况下效率低
																	 归并排序:需要额外内存空间
																	 堆排序:在三种排序中相对较慢

day37 2023.04.03	 python			在解释器首行进行声明可以用特定编码解释文件: # -*- encoding:gbk -*-
															任何编码转换成Unicode的过程都叫解码
															解码: str.decode("字符串编码格式,如gbk")
															编码: str.encode("编码格式")
															操作文件:
																			f = open("文件名", mode="r/w/a", encoding="utf-8")	:打开	r-只读 w-创建/覆盖 a-添加内容 w+写读 r+读写 a+追加读		rb/wb/ab为二进制模式(可以打开图片)
																			open不会直接将文件全部载入内存
																			f.write("内容")	:写操作
																			f.read()	:读出所有内容
																			f.close()	:保存并关闭
																			f.readline()只读取文本文件中的一行
																			f.readlines()读取全部文本并存储为列表
																			二进制文件写入文本也需要使用二进制格式(f.write(str.encode="utf-8"))
																			f.seek(字节)	:可以修改已打开的文件读取/写入字节位置
																			f.tell()	:返回光标当前位置
																			f.truncate()	:从光标处截断文件	配合seek(0)可以清空文件
																			如何修改文件: 加载文件 在内存中修改(此时文件为str) 把新内容写到硬盘													 占内存
																									 循环加载每行文件 保留不修改文件添加到新文件 修改文件后添加到新文件 删掉原文件			占硬盘
															.flush()	:可以强制把内存中的数据写到硬盘上

															sys模块:主要用于读取外部指令(终端中的)	python3 __.py 外部参数1 外部参数2
																			import sys	(sys.argv[0]是__.py文件)
																			变量名1 = sys.argv[1]		外部参数1会赋值给变量名1
																			变量名2 = sys.argv[2]		外部参数2会赋值给变量名2
																			可以通过该模块使程序调用外部参数

day38 2023.04.05   python			函数:
																	默认参数(需在最后): 在定义函数时直接赋值(def None(x,y,z=1))
																	位置参数(需在最前): 在调用函数时不需要写函数的参数定义名
																	关键参数(指定参数): 在调用函数时参数可以不按顺序但需要写函数定义时的参数名
																	非固定参数: *args 可以在调用时无限传值
																						函数内调用时args为元组, 需要args[i]
																						 **kwargs	调用时可以写 str="xxxxx"
																						函数内调用时kwargs为字典 kwargs.get("key")
																	地址传递:以上为值传递
																					将列表/字典等数据类型传递进函数时可以在函数中进行更改元素(append这种)
																					(列表的内存地址传递给函数，修改元素时是修改元素的内存地址而不是列表的内存地址)
																					函数执行传参时, 传递的是内存地址
																					函数的返回值也是内存地址
																					由于python的内部优化(缓存与驻留机制), 字符串与数字再次创建时不会使用新的内存地址
														  内置函数:
																			abs(-10): 取绝对值
																			pow(2,5): 2**5
																			all(items): 布尔判断, item可以为列表等, 全部为True即all()为True
																			bool(item): 判断itme的布尔值
																			any(items): 布尔判断, 一个为True即any()为True
																			chr(int):	打印ASCII值对应的字符
																			ord("字符"): 打印字符的ASCII码
																			dict(空/内容): 生成一个空/或带内容的字典
																			dir(): 打印当前程序(作用域)下的所有变量名
																			locals(): 所有变量名+变量值
																			m = map(函数(不加括号,只能定义1个参数), 元素(列表)): 将元素(列表)依次交给函数进行运算
																			map调用后不会立即执行(迭代器), 使用for i in m时才会开始执行
																			max()/min(): 取最大/最小值
																			sum(-11, 22, 33, 44, 55): 求和
																			divmod(9, 2): 求商和余数
																			filter(函数, 列表): 将列表中元素依次传入函数, 返回的元素若为True, 则保留(过滤器)
																			zip(a,b): 将a,b(列表)配对 使用循环时开始执行(迭代器)
																			round(double, int): 将double保留int位小数(四舍五入)
																			bin/oct/hex(): 十进制转二/八/十六进制
																			callable(): 判断是否可执行, 就是后面是否可以加括号
																			hash(): 取哈希值
																			help/id/input/int/len/list/open/enumerate/str/type..

day39 2023.04.06	 python			导入模块:
																			import module
																			from module import xx
																			from module import xx as rename
														  自定义模块路径:
																					  import sys
																						import os				# __file__当前文件路径  os.path.absname(__file__)当前文件的绝对路径
																						base_path = os.path.dirname(os.path.dirname(__file__))			# 当前文件的上一层文件路径
																						sys.path.append(r"D:\xx\xx")			# 往默认路径中添加输入的路径
																						pycharm中默认会将项目目录加入到sys.path中
																						import可以直接导入一个包含__init__.py的包, 然后直接加载此__init__文件
																						import: 常用于项目根目0录下包/模块级别的导入
																						from: 常用于成员、嵌套的包/模块时
															第三方开源模块:
																						网站地址: https://pypi.org/	镜像网址 清华/阿里/豆瓣(https://pypi.douban.com/simple/)
																						修改pip源: pip config set global.index-url https://pypi.douban.com/simple/
																						命令行: pip install xxxxx (-i http...)
															包(文件夹):在目录下创建 __init__.py 即可成为包, 包可跨层级导入
																				from 包.子包.模块名 import 函数名
																				调用包时会直接执行 __init__.py 文件
																				__init__文件中一般可以写该包的注释""" 注释 """
																				相对导入: from . import xxxxx(当前路径)
																							  : from .. import xxxxx(上一级路径)
																				相对导入只能在模块里使用(包里)
																				执行一个py文件时: __name__ = "__main__"
																				导入一个py文件时: __name__ = "模块名"
																				一般主文件下会有: if __name__ == "__main__":
															os模块:
																		 os.getcwd(): 获得当前Python脚本工作的目录路径
																		 os.listdir(): 返回指定路径下的文件和目录名
																		 os.walk(): 遍历指定路径下的所有文件夹与所有文件
																		 可以使用for path, folder_list, file_list in date: 来输出
																		 						for file_name in file_list:
																										file_abs_path = os.path.join(path, file_name)
																										ext = file_abs_path.rsplit(".",1)[-1]
																										if ext == "mp4"
																												print(file_abs_path)
																		 os.remove(): 用来删除一个文件
																		 os.removedirs(r"c:\python"): 删除整个目录
																		 os.path.isfile(): 检验给出的路径是否是一个文件
																		 os.path.isdir(): 检验给出的路径是否是一个目录
																		 os.path.exists(): 检验给出的路径是否真实存在
																		 os.path.dirname(): 获取上一级目录
																		 os.path.abspath(文件名): 获取文件绝对路径
																		 os.path.basename(): 获取文件名
																		 os.system(): 运行shell命令
																		 os.rename(old, new): 重命名
																		 os.makedirs(r"c:\python\test"): 创建多级目录, 不指定盘的话即为当前目录下创建
																		 os.mkdir("test"): 创建单个目录
																		 os.stat(file): 获取文件属性
																		 os.path.getsize(filename): 获取文件大小
																		 os.path.join(base_path, 'files', 'info.txt'): 路径拼接
															sys模块:
																			sys.path: 获取环境变量
																			sys.argv[]: 获取脚本参数
															时间戳: 从1970.1.1 00.00.00开始按秒计算偏移量
															格式化的时间字符串: "2020-10-03 17:54"
															时间元组: 月、日、一年中的第几天计算从1开始, 周、时、分、秒计算从0开始
															time模块:
																			 time.time(): 时间戳(1970年起)
																			 time.timezone(): 时区, 但是返回的结果是秒, 转换为小时需要/60/60
																			 time.sleep(): 延迟时间, 按秒算
																			 time.localtime([secs]): 按时间戳转换为当前地区的时间元组，不提供secs则为当前时间
																			 time.gmtime([secs]): 将时间戳转换为0时区的时间元组
																			 time.mktime(t): 将一个元组对象转换为时间戳
																			 time.strftime("%Y-%m-%d %X", time.localtime()): 将时间元组转换为特定格式, 上式为转换当前时间
																			 time.strptime(str, "%Y-%m-%d %X"): 根据字符串与其格式转成时间元组
														  datetime模块:
															 						 datetime.now(): 返回当前时间, 使用print可以直接打印格式化时间
																					 datetime.utcnow(): 太平洋时间
																					 datetime.now(timezone(timedelte(hours=7))): 当前东七区时间
																					 datetime.fromtimestamp(): 时间戳转换成时间
																					 datetime.timestamp(): 时间转时间戳
																					 datetime.now() + datetime.timedelta(days=140, minutes=5): 可以增加/修改时间
																					 d = datetime.datetime.now()
																					 d.replace(year=xxxx, month=x, ...): 可以直接替换(修改)时间
																					 text = "2023-04-22"
																					 datetime.strptime(text, "%Y-%m-%d"): 将用户输入的时间格式化后可用进行加减比较的操作
																					 v1 = datetime.now(), v1.strftime("%Y-%m-%d %H:%M:%S"): 将时间格式转化为字符串格式
														  openpyxl(Excel)模块:
																								 from openpyxl import Workbook
																								 wb = Workbook()		# 创建Excel
																								 wb.save("命名.xlsx")			# 保存Excel文件
																								 wb2 = load_workbook("xxxx.xlsx")		# 直接打开xlsx文件
																								 wb2.sheetnames()			# 获取表格全部sheet名
																								 sheet = wb.active		# 获取活跃的Sheet
																								 sheet.title = "命名"		# 更改Sheet名
																								 wb.remove(sheet):			# 删除工作表
																								 wb.create(sheet2):			# 创建工作表
																								 sheet["C7"] = "xxxxx"		# 在xlsx指定位置填入数据
																								 sheet.append([内容1, 内容2, 内容3]): 在最新一行加入三个数据(占3个)
																								 sheet = wb2.get_sheet_by_name("sheet名")			# 获取列表sheet
																								 sheet["B5"].value			# 获取该sheet指定位置内容
																								 for cell in sheet["B5:B10"]:			# 循环切片获取数据
																								 		 print(cell[0].value)			# cell.value为元组
																								 for row in sheet:			# 遍历打印
																								 		 for cell in row:
																										 		 print(cell.value, end=",")
																								 for row in sheet.iter_rows(min_row=4, max_row=21, min_col=0, max_col=5):			# 切片4-21行, 切5列	按行循环
																								 		 for cell in row:
																										 		 print(cell.value, end=",")
																								 for column in sheet.columns:			# 按列循环
																								 for colimn in sheet.iter_cols(min_col=3, max_col=4, min_row=x, max_row=y):		# 切片3-4列， 切y-x行	 按列循环

																								 from openpyxl.styles import Font, colors, Alignment
																								 bold_itatic_24_font = Font(name='字体名', size=24, italic(斜体)=True, color=colors.RED, bold(粗体)=True)			# 声明字体熟悉
																								 sheet['A1'].font = bold_itatic_24_font			# 设置单元格字体样式
																								 sheet['B1'].alignment = Alignment(horizontal(水平方向)='center', vertical(垂直方向)='center')			# 设置字体垂直水平方向
																								 sheet.row_dimensions[3].height = 40			# 设置行高
																								 sheet.column_dimensions['C'].width = 30	# 设置列宽
														  email与smtplib模块:
																								import smtplib
																								from email.mime.text import MIMEText			# 构造邮件正文
																								from email.header import Header			# 邮件头(收件人等)
																								# 登录服务器
																								smtp_obj = smtplib.SMTP_SSL("服务器地址", 端口号)			# 发件人邮箱中的SMTP服务器和端口号
																								smtp_obj_login("用户名", "密码")			# 发件人账号密码/客户端专用密码
																								smtp_obj.set_debuglevel(1)			# 显示调试信息
																								# 设置邮件头信息
																								msg = MIMEText("内容", "类型", "编码格式")
																								msg["From"] = Header("发件人(姓名)", "utf-8")			# 发送者
																								msg["To"] = Header("收件人(姓名)", "utf-8")			# 接收者
																								msg["Subject"] = Header("主题名", "utf-8")			# 标题
																								# 发送
																								smtp_obj.sendmail("发件人邮箱", “收件人邮箱(可以是列表)”, msg.as_string())
																								服务器地址:账户里开启SMTP服务

day40 2023.04.07   python     tuple(元组):
																					有序且<不可变>的容器(11,22,33,[44,55])
																					其中11,22,33不可变,但list内部元素可以进行修改
																					元组可以相加、相乘、获取长度、索引、切片、步长、for循环
																					tuple(字符串/列表): 拆分后转换成元组
															set(集合):
																				无序、可变、不允许数据重复的容器(爬虫爬数据防止重复可以用集合)
																				v1 = set(11, 22, 33, "desire")
																				set.add("元素")： 添加元素
																				set.discard("元素"): 删除元素
																				s3 = s1 & s2或者s3 = s1.intersection(s2): 取交集
																				s3 = s1 | s2或者s3 = s1.union(s2): 取并集
																				s3 = s1 - s2或者s3 = s1.difference(s2): 取差集, s1有且s2没有的值
																				可以使用len、for   集合是无序的，无法通过索引取值
																				set(str/list/tuple): 转换成集合(可以用来去重)
																				集合的元素必须是可哈希的(int/bool/str/tuple)(转换时若内容包含列表则会报错)
																				<集合中的元素查找速度快>  True与False本质上是1与0,所以在集合中不能同时存在T/1或F/0
																				集合中可以包含元组，但是元组中不能含有列表

day41 2023.04.08   python			==: 比较两个值是否相等
															is: 比较两个内存地址是否一致
															位运算(二进制运算):
																								&: 与(都为1)
																								|: 或(只要有一个为1)
																								^: 异或(值不同)
																								-: 取反
																								<< 2: 左移动2位
																								>> 2: 右移动2位
															如2**n = 1 << n
															  计算数的一半 = x >> 1
															shutil模块:
																				压缩文件: shutil.make_archive(base_name=r'D:\xxx\xxx\x1', format='zip', root_dir=r'D:\xxxxxx\xx')
																				压缩后放置路径/压缩格式/压缩文件路径
																				解压文件: shutil.unpack_archive(filename=r'D:\sxxx\sxxx\x1.zip', extract_dir=r'D:sxxx\sxxx\xxx', format='zip')
																				压缩包路径/解压路径/压缩包格式


day42 2023.04.09   python     v1 = "as" and "zxc": 				v1 = "zxc"
															v2 = "" and "zxc": 					v1 = ""
															v3 = 1 or 8: 								v3 = 1
															v4 = 0 or 8: 								v3 = 8
															func(函数):
																					当函数声明中含有可变类型的默认值(list/dict/set),函数在调用一次后再次调用时不会重新创建默认值
																					如def list(a, b=[1,2]):
																								b.append(3)
																					调用第二次list函数时, b=[1, 2, 3, 3]
																					若中间调用函数时赋值了, 但[1, 2, 3, 3]的内存地址并没有被清除, 再次使用默认参数时会变成[1, 2, 3, 3, 3]
																					python为解释型语言, 函数的调用需要在函数的定义之后
																					函数名可以当做列表, 字典, 集合的元素, 当x = list[5]中为函数名时(不能加括号), x为函数的返回值
																					对函数名重新赋值, 函数名将不再指代函数
														  global var: 在函数中声明全局变量, 可以对已有的全局变量进行重新赋值, 不适用global即为创建新的同名变量

day43 2023.04.10   python     函数调用元素优先在自己的作用域内进行查找
															闭包:
																	 可以将数据与多个函数嵌套进一个函数中, 封装数据防止污染全局(当全局变量有其他函数用不到时可以使用, 使用的较少)
																	 在函数嵌套之后, 可以在内部函数使用外部函数的参数, 使得调用函数时可以使用不同的参数
															并行多线程:
																				from concurrent.futures.thread import ThreadPoolExecutor
																				POOL = ThreadPoolExecutor(10)			# 线程池
																				future = POOL.submit(函数名)			# 指定一个线程执行函数, 使用for函数时不会执行完1个再执行下1个, 而是同时执行
																				future.add_done_callback(函数名)			# 每当执行完一次线程时会内部执行函数
																				可以通过闭包配合多线程(如下载3个视频...callback(outer(item[0]())))...outer为闭包函数, item[0]为视频名称
																				outer中含有done(arg)函数, 并且return done, 于是视频名会传进done, 于是会执行三次done函数, 保存为三个文件(done函数中内容)
															装饰器:
																		基于@语法和函数闭包, 将原函数封装在闭包中, 然后将函数赋值为一个新的函数(内层函数), 执行函数时再在内层函数中执行闭包中的原函数
																		在某个函数1上方使用 @函数名2 , python内部会自动执行 函数名2(函数1) ,再将结果赋值给函数1
																		@outer									# func = oubter(func)
																		def func():							#	func()  (此时func = inner, 整体执行下来相当于执行了func()与inner内部的代码)
																				pass

																		def outer(origin):			# origin=func
																				def inner(*args, **kwargs):
																						执行代码前的内容
																						res = origin(*args, **kwargs)			# 调用原来的func函数, res = func()
																						执行代码后的内容
																						return res			# 返回func()的返回值
																				return inner
																		(outer需要再func之上, 因为python为解释型语言)

day44 2023.04.11   python     匿名函数:
																			基于lambda表达式实现定义一个可以没有名字的函数
																			格式为: 变量 = lambda 参数: 函数体(lambda x: x + 100)
																			(一行可以搞定的函数可以使用匿名函数)
															三元运算:
																			简单的条件语句, 可以基于三元运算实现
																			date = "臭不要脸" if "苍老师" in num else "正经人"
																			配合匿名函数:
																									func = lambda x: "大了" if x > 66 else "小了"
															生成器:
																		当函数中有yield存在时, 这个函数就是生成器函数, 此函数可以大大节省内存开销(每运行一次时创建一次)
																		执行生成器函数时, 函数体默认不会被执行; 返回的是一个生成器对象
																		v1 = func()			# func为生成器函数
																		v2 = next(v1)			# next里面放生成器对象, 进入生成器函数并执行其中的代码, 将yield后的内容返回到新变量
																		next(v1)			# 从上一次返回的yield位置继续向下执行, 全部执行完时会报错提示执行完毕
																		基于for循环执行生成器对象, 此时运行完不会报错
																		data = func()
																		for item in data:
																				next(data)
																				print(item)
																		yield from 函数: 可以在生成器执行时跳到from后面的函数中进行循环(如果函数里有yield的话)
															推导式:
																		常用于创建列表、集合、字典、元组
																		num_list = [ i for i in range(10)]			# 第一个i为列表格式, 可以是[i, i]、"str{}".format(i)等
																		range(10)后面可以添加if语句(如 if i > 6)
																		元组:			# 不会立刻执行内部循环取生成数据, 而是得到一个生成器对象
																				data = ( i for i in range(10) )
																				for item in data:
																						print(item)
																		data_list = [lambda x: x + i for i in range(10)]
																		v1 = data_list[0](100)
																		v2 = data_list[3](100)
																		print(v1, v2)
																		# 最后结果应该为两个109, 在lambda中循环i时, 函数体不执行, 而是创建10个函数导data_list中, 只有调用时才会调用i(循环完后i为9)
																		推导式支持嵌套:
																									data = [ [i,j] for j in range(5) for i in range(10)]
																									data = [[0,1],[0,2]....]

day45 2023.04.13   python     hashlib模块:md5加密
																					def md5(origin, salt="qweozuxconaskdiashk"):
																							hash_object = hashlib.md5(salt.encode('utf-8'))			# 加盐
																							hash_object.update(origin.encode('utf-8'))				# 内容加密
																							result = hash_object.hexdigest()

day46 2023.04.22   python     json模块: 可以将python的数据格式转换为json格式的数据, 也可以反过来转换
																				用于跨语言数据传输, 如python数据传入到java需要先将数据转换为json格式
																				import json
																					转换为json格式(序列化): data = json.dumps("数据", (ensure_ascii=False)) 后面的参数为不将中文转换为Unicode格式
																					不支持的格式可以先转化为字符串的格式, 如set集合
																					转换为python格式(反序列化): data = json.loads("数据")
																					json.dump(data, file): 将数据序列化后写入到文件中
																					json,load(file): 读取文件中的数据病反序列化为python的类型
															正则表达式:
																				import re
																				re.findall("字符串", "变量名"): 找文本中的字符串
																				"[abc]": 找文本中的a或b或c
																				"q[abc]": 找qa或qb或qc
																				"[^abc]": 除了a和b和c的任意字符
																				"[a-z]"/"[0-9]": 找任意a-9/0-9
																				".": 除了换行符以外的任意字符(r.o 为 r任意o)
																				"+": 出现一次或者N次(r.+o 可以为 rzxcaoosdahjo) 贪婪匹配, 能匹配长的就匹配长的
																				"*": 零次或N次
																				"+?": 非贪婪匹配
																				"?": 零次或一次
																				"\w": 字母或数字或下划线(汉字)
																				"\d": 数字
																				"\s": 任意的空白符, 包括空格、制表符等
																				"{n}": 出现n次
																				"{n,n2}": 出现n次或更多次(或n次到n2次)
																				"()": 分组, 匹配成功后只提取括号内的值, 可以多个括号, 或者括号里面套括号, 会输出元组
																				"(?P<名称>正则)": 命名分组, 配合finditer和groupdict可以输出字典
																				"|": 或
																				"^...$": 起始和结束, 必须以...中的正则表达式格式(格式校验)
																				\: 转义字符
																				re模块其余函数：
																			  .match: 从起始位置开始匹配, 匹配成功返回一个对象, 否则返回None
																				.search: 浏览整个字符串去匹配第一个对象, 匹配失败返回None
																				.group: 将返回的对象转换为字符串? 可以用于print
																				.sub: 替换匹配成功的位置, 类似于replace
																				.split: 根据匹配成功的位置进行分割
																				.finditer: 迭代器, 在循环的过程中每循环一次匹配一次 使用.group获取
															BeautifulSoup模块可以提取评论
															单文件可完成的简单内容:
															1."""..."""注释
															2.导入模块顺序(内置、第三方、自定义)
															3.全局变量大写
															4.函数名命名规范&函数功能注释
															5.TODO 信息(下一期要完成的任务)
															6.部分功能代码注释
															7.if __name__ == '__main__' 主文件

															nolocal: 针对上一级作用域
															nonlocal name; name = 123: 将上一级作用域的name改为123


															深浅拷贝:
																			import copy
																			深浅拷贝一般都是说的可变类型: set、list、dict(不可变类型在进行深浅拷贝时无意义-内部都不会去拷贝(拷贝id))
																			# 浅拷贝: 针对可变类型只拷贝第一层, 内部的可变/不可变类型都不会被拷贝
																				v1 = [...]
																				v2 = copy.copy(v1)
																				相当于新建一个列表(id不同)而不是指向内存地址, 但列表内的数据还是指向同一个地址(id相同)
																		  # 深拷贝: 可变类型的外层被拷贝, 内部的不可变类型不会被拷贝, 可变类型会被拷贝
																				v1 = [...]
																				v2 = copy.deepcopy(v1)
																			元组比较特殊, 当元组内都是不可变类型时不会被拷贝, 若内部含可变类型, 元组也会被拷贝一份

day47 2023.04.23   python     面向对象:
																			1.创建类(驼峰式命名)
																			2.创建方法(函数放进类中)
																			3.实例化对象(对象名 = 类名())
																			4.对象调用方法
																			实例化对象时会自动执行__init__方法, 可以在内存中初始化一些函数
																			适合场景:
																							1.做数据封装方便后续调用
																							2.先封装数据且后续并使用方法再对数据进行加工处理
																							3.创建同一类的数据, 同类数据可以具有相同的功能
																							4.代码的大量重用
																			成员:
																					绑定方法: 类中的方法
																					直接通过类调用方法而不是实例的话, 方法的参数需要自己去传递(非主流)
																					实例变量: 类中__init__初始化的变量

															封装、继承、多态:
																			封装: 将同一种类的方法封装到一个类中
																					 /将数据封装到对象中, 实例化对象时通过__init__初始化方法在对象中封装数据便于以后使用
																			继承: 子类(派生类)继承父类(基类)
																						子类调用方法时优先在自己的类中查找, 若自己类中没有则去父类中寻找
																						python支持多继承, 调用方法时, 优先从先继承的类中寻找
																			多态: 参数为多种类型
																						python天生支持多态, 像java中函数声明变量需要指定类型, 多态需要依靠父类
															实例名.实例变量 = "xxx": 修改实例变量
															实例名.变量 = "xxx": 增加实例的实例变量 (同理, 可以增加类变量)
															调用变量时优先调用实例变量, 若实例变量不存在则寻找类变量, 还不存在则寻找父类的类变量
															绑定方法: 至少有一个叫self的参数, 一般通过实例化对象调用
															类方法: 至少有一个叫cls的参数, 上方需要有@classmethod的装饰器(python自带)
																			可以通过类与实例化对象调用, cls会代表类
															静态方法: 没有默认参数, 有一个@staticmethod的装饰器(python自带)
																				可以通过类与实例化对象调用

															@property: 在绑定方法上方加入装饰器, 则变为属性, 调用方法时就不用加()了
															@方法名.setter: 调用方法时传入参数可以改为 实例对象.方法名=参数
															@方法名.deleter: 调用方法时可以改为 del 实例对象.方法名

															成员修饰符: 私有变量, 只能在内部自己调用
																				 self.__实例变量名 = name(类变量(属性)与类方法同理)
																				 父类中的私有成员, 子类无法继承(无法调用)

															特殊成员:
																			__init__: 初始化方法
																			__new__: 构造方法, 在__init__之前触发, 创建空对象并返回(可省略)
																			__call__: 在实例化的对象后面直接加括号会执行__call__方法(obj = Foo(); obj())
																			__str__: 该方法必须返回一个字符串类型, data = str(实例化对象)会获取该返回值(不创建直接print其实也行)
																			__dict__: 实例化对象.__dict__会把该类的实例变量转化为字典返回
																			__setitem__(self, key, value): 使用 实例["xxx"] = xxx 时会自动触发
																			__getitem__(self, item): 使用 实例["xxx"] 时会自动触发
																			__delitem__(self, key): 使用 del 实例["xxx"] 时会自动触发
																			__enter__: 使用 with 实例(类()) as x 时会执行该方法, return f相当于 x=f
																			__exit__: __with__执行完毕后会执行该方法
																			__add__(self, other): 定义后支持对象相加, 方法内的返回值赋予变量(v3 = 对象(self)+对象(other))
																			上面的方法也适用于加减乘除等
																			__iter__: 需要返回self  如果对象为迭代器对象, 则该类创建的对象为可迭代对象
																			__next__: 返回下一个数据  可以使用 对象.__next__()/next(对象) 执行
																			for item in 对象: 首先执行__iter__并获取返回值, 随后一直反复执行next(对象)
																			生成器(yield)是一种特殊的迭代器
