23.03.29: 时间复杂度:用来评估算法运行效率的一个式子
          单条/多条语句 O(1)
          一层for循环 O(n)
          二层for循环 O(n^2)
          while n>1: print(n) n=n//2   O(logn)(循环减半)
          常见的 1 < logn < n < nlogn < n^2 < n^(2)*logn < n^3

          空间复杂度:用来评估算法内存占用大小的式子
            使用了几个变量 O(1)
            使用了长度为n的一维列表  O(n)
            使用了m行n列的二维列表  O(mn)

          <空间换时间> 以速度优先


          递归:1.调用自身 2.结束条件
            汉诺塔问题:def hanoi(n, a, b, c):
                        if n>0:
                          hanoi(n-1, a, c, b)
                          print("moving form &s to &s" % (a, c))
                          hanoi(n-1, b, a, c)


          查找：在一些数据元素中，通过一定的方法找出给定关键字相同的数据元素的过程。
          列表查找(线性表查找): 从列表中查找指定元素
            输入: 列表、待查找元素
            输出: 元素下标(未找到元素时一般返回None或-1)
            如Python中index() Java中indexOf()

          顺序查找/线性查找:
          def linear_search(data_set, value):
              for i in range(len(data_set)):
                  if data_set[i] == value:
                      return i
                  return None

          二分查找/折半查找:
          def binary_search(li, val):
              left = 0
              right = len(li) - 1
              while lift <= right:
                  mid = (left + right) // 2
                  if li[mid] == val:
                      return mid
                  elif li[mid] > val:
                      right = mid - 1
                  else:
                      left = mid + 1
              else:
                  return None


          排序方法：
              冒泡排序:列表每两个相邻的数，如果前面比后面大，则交换这两个数
              def bubble_sort(li):
                  for i in range(len(li)-1):    # i是第几趟
                      exchange = False
                      for j in range(len(li)-i-1):
                          if li[j] > li[j+1]:
                              li[j], li[j+1] = li[j+1], li[j]   时间复杂度: O(n^2)
                              exchange = True
                      if not exchange:
                          return

              选择排序:一趟排序记录最小的数， 放到第一个位置
              def select_sort(li):
                  for i in range(len(li)-1):
                      min_loc = i
                      for j in range(i+1, len(li)):
                          if li[j] < li[min_loc]:
                              min_loc = j
                      li[i], li[min_loc] = li[min_loc], li[i]   时间复杂度: O(n^2)

              插入排序:每次从无序区摸一张牌，插入到手里已有牌的正确位置
              def insert_sort(li):
                  for i in range(1, len(li)):   # i表示摸到的牌的下标
                      tmp = li[i]     # 记录抽出的元素大小
                      j = i - 1   # j这里指的是已经排好序的最后一个元素下标
                      while li[j] > tmp and j >= 0:
                          li[j+1] = li[j]
                          j -= 1
                      li[j+1] = tmp    时间复杂度: O(n^2)


              快速排序: 取一个元素p(第一个元素)，使元素p归为；
                       列表被p分成两部分，左边都比p小，右边都比p大
                       递归完成排序
              框架def quick_sort(data, left, right):
                    if left < right:    # 至少两个元素
                        mid = partition(data, left, right)
                        quick_sort(data, left, mid - 1)   # 排序第一个元素归位后的左边列表
                        quick_sort(data, mid + 1, right)  # 排序第一个元素归位后的右边列表

                  def partition(li, left, right):
                      tmp = li[left]
                      while left < right:
                          while left < right and li[right] >= tmp:   # 从右边找比tmp小的数
                              right -= 1    # 往左走一步
                          li[left] = li[right]    # 把当前right的值写到left
                          while left < right and li[left] <= tmp:
                              left += 1
                          li[right] = li[left]    # 把当前left的值写到right上
                      li[left] = tmp    # 把tmp归位
                      return left   时间复杂度nlogn    最坏情况下复杂度会变为n^2
                      可以在第一步将第一个元素与随机元素换位来避免最坏情况

              树与二叉树:一种数据结构, 如目录结构
                        数是一种可以递归定义的数据结构
                        根节点:最上层的节点		叶子节点:最下层的节点
                        深度/高度:最深有几层		树的度:最多的分叉个数
                        孩子节点/父节点:字面意思		子树:下一级的所有节点(包括节点的节点)
                  二叉树:每个节点最多有两个子节点(左节点/右节点)
                满二叉树:每个节点均有两个子节点
              完全二叉树:在满二叉树的基础上最下一层从右向左缺失(满二叉树为特殊的完全二叉树)
                        父节点为i位时, 左节点是父节点的2i+1 右节点即为2i+2
                        左/右节点为i时, 父节点为(i-1or2)/2

              堆排序:
                    大根堆:完全二叉树下，任一节点都比其子节点大(父比子大)
                    小根堆:完全二叉树下，任一节点都比其子节点小(父比子小)
                    向下调整:当根节点的左右子树都是堆时，可以通过一次向下调整使其成为堆
                    过程1.建立堆
                        2.得到堆顶元素为最大元素
                        3.去掉堆顶，将堆最后一个元素放到堆顶，进行向下调整
                        4.堆顶元素为第二大元素
                        5.重复步骤3，直到堆变空
                    def sift(li, low, high):		# low为第一个数，high为最后一个数
                        i = low		# 最开始指向根节点(tmp要去的位置)
                        j = 2 * i + 1		# 左节点
                        tmp = li[low]		# 把堆顶i位置的数存起来
                        while j <= high:		# j位置有数则继续循环
                            if j + 1 <= high and li[j+1] > li[j]:		# 存在右节点且比左大
                                j = j+1		# j指向右节点
                            if li[j] > tmp:
                                li[i] = li[j]
                                i = j			# i与j往下一层
                                j = 2 * i + 1
                            else:		# tmp更大，将tmp放到i的位置上
                                li[i] = tmp		# 将tmp放到某一父节点
                                break
                        else:
                            li[i] = tmp		# j越界后，将tmp放到子节点(可以删掉两次与else直接在循环外执行一次)

                    def heap_sort(li):
                        n = len(li)
                        for i in range((n-2)//2, -1 -1):
                            sift(li, i, n-1)
                        for i in range(n-1, -1, -1):
                            li[0], li[i] = li[i], li[0]
                        sift(li, 0, i - 1)		# i-1是新的high    时间复杂度O(nlogn)

              归并排序:
                      归并:假设有两段有序列表，将其合成为一个有序列表即为归并(左右互相按顺序比大小，小/大的一方提出)
                      def merge(li, low, mid, high):  # low:左箭头 mid:中间数 high:又箭头
                          i = low
                          j = mid + 1
                          while i <= mid and j <= high: # 两边都有数
                              if li[i] < li[j]:
                                  list_tmp.append(li[i])
                                  i += 1
                              else:
                                  list_tmp.append(li[j])
                                  j += 1
                          while i <= mid:
                              list_tmp.append(li[i])
                              i += 1
                          while j <= high:
                              list_tmp.append(li[j])
                              j += 1
                          li[low:high+1] = list_tmp

                      def merge_sort(li, low, high):  # 左边排序，右边排序，左右合并，递归！
                          if low < high:  # 至少有两个元素，递归
                              mid = (low + high) // 2
                              merge_sort(li, low, mid)
                              merge_sort(li, mid+1, high)
                              merge(li, low, mid, high)     时间复杂度:O(nlogn)  空间复杂度:O(n)

              冒泡排序最好情况时间复杂度为O(n)
              空间复杂度:快速平均O(logn)、最坏O(n)
                        归并O(n)
                        其余为O(1)
              稳定性:冒泡、插入、归并稳定    稳定的排序可以保证相同内容在排序后相对位置不变(挨个换的是稳定的，跳着换的是不稳定的)
                    选择、快速、堆不稳定

              希尔排序:
                      一种分组的插入排序方法
                      第一次:d1=n/2, 每组相邻d1, 各组相对位置的两个数进行排序
                      之后:d2=d1/2, 重复排序过程直到di=1
                      def insert_sort_gap(li, gap):
                          for i in range(i, len(li)):
                              tmp = li[i]
                              j = j - 1
                              while j >= 0 and li[j] > tmp:
                                  li[j+1] = li[j]
                                  j -= gap
                              li[j+gap] = tmp
                      def shell_sort(li):
                          d = len(li) // 2
                          while d >= 1:
                              insert_sort_gap(li, d)
                              d //= 2   时间复杂度最坏情况为O(n^2), 与gap有关(以上为n/2)

              计数排序:
                      计数每个元素的个数, 然后排序
                      def count_sort(li, max_count=100):
                          count = [0 for i in range(max_count+1)]     # 生成一个长度为max_count+1, 值全为0的列表
                          for val in li:
                              count[val] += 1
                          li.clear()
                          for index, value in enumerate(count):
                              for i in range(value):
                                  li.append(index)      时间复杂度O(n), 但限制很多(如需要数据范围小, 必须是整数)

              桶排序:
