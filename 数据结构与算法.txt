23.03.29: 时间复杂度:用来评估算法运行效率的一个式子
          单条/多条语句 O(1)
          一层for循环 O(n)
          二层for循环 O(n^2)
          while n>1: print(n) n=n//2   O(logn)(循环减半)
          常见的 1 < logn < n < nlogn < n^2 < n^(2)*logn < n^3

          空间复杂度:用来评估算法内存占用大小的式子
            使用了几个变量 O(1)
            使用了长度为n的一维列表  O(n)
            使用了m行n列的二维列表  O(mn)

          <空间换时间> 以速度优先


          递归:1.调用自身 2.结束条件
            汉诺塔问题:def hanoi(n, a, b, c):
                        if n>0:
                          hanoi(n-1, a, c, b)
                          print("moving form &s to &s" % (a, c))
                          hanoi(n-1, b, a, c)


          查找：在一些数据元素中，通过一定的方法找出给定关键字相同的数据元素的过程。
          列表查找(线性表查找): 从列表中查找指定元素
            输入: 列表、待查找元素
            输出: 元素下标(未找到元素时一般返回None或-1)
            如Python中index() Java中indexOf()

          顺序查找/线性查找:
          def linear_search(data_set, value):
              for i in range(len(data_set)):
                  if data_set[i] == value:
                      return i
                  return None

          二分查找/折半查找:
          def binary_search(li, val):
              left = 0
              right = len(li) - 1
              while lift <= right:
                  mid = (left + right) // 2
                  if li[mid] == val:
                      return mid
                  elif li[mid] > val:
                      right = mid - 1
                  else:
                      left = mid + 1
              else:
                  return None


          排序方法：
              冒泡排序:列表每两个相邻的数，如果前面比后面大，则交换这两个数
              def bubble_sort(li):
                  for i in range(len(li)-1):    # i是第几趟
                      exchange = False
                      for j in range(len(li)-i-1):
                          if li[j] > li[j+1]:
                              li[j], li[j+1] = li[j+1], li[j]   时间复杂度: O(n^2)
                              exchange = True
                      if not exchange:
                          return

              选择排序:一趟排序记录最小的数， 放到第一个位置
              def select_sort(li):
                  for i in range(len(li)-1):
                      min_loc = i
                      for j in range(i+1, len(li)):
                          if li[j] < li[min_loc]:
                              min_loc = j
                      li[i], li[min_loc] = li[min_loc], li[i]   时间复杂度: O(n^2)

              插入排序:每次从无序区摸一张牌，插入到手里已有牌的正确位置
              def insert_sort(li):
                  for i in range(1, len(li)):   # i表示摸到的牌的下标
                      tmp = li[i]
                      j = i - 1   # j指的事手里的牌的下标
                      while li[j] > tmp and j >= 0:
                          li[j+1] = li[j]
                          j -= 1
                      j[j+1] = tmp    时间复杂度: O(n^2)


              快速排序: 取一个元素p(第一个元素)，使元素p归为；
                       列表被p分成两部分，左边都比p小，右边都比p大
                       递归完成排序
              框架def quick_sort(data, left, right):
                    if left < right:    # 至少两个元素
                        mid = partition(data, left, right)
                        quick_sort(data, left, mid - 1)
                        quick_sort(data, mid + 1, right)

                  def partition(li, left, right):
                      tmp = li[left]
                      while left < right:
                          while left < right and li[right] >= tmp:   # 从右边找比tmp小的数
                              right -= 1    # 往左走一步
                          li[left] = li[right]    # 把当前right的值写到left
                          while left < right and li[left] <= tmp:
                              left += 1
                          li[right] = li[left]    # 把当前left的值写到right上
                      li[left] = tmp    # 把tmp归位
                      return left   时间复杂度nlogn    最坏情况下复杂度会变为n^2
                      可以在第一步将第一个元素与随机元素换位来避免最坏情况
